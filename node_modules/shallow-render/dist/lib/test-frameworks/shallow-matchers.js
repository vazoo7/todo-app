"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jasmineToJestMatcher = (jasmineMatcher) => (actual, expected) => {
    const { pass, message } = jasmineMatcher().compare(actual, expected);
    return { pass, message: () => message };
};
const jasmineMatchers = {
    toHaveFound: () => ({
        compare: (actual, expected) => ({
            pass: actual.length === expected,
            message: `Expected to find exactly ${expected} but found ${actual.length}`,
        }),
    }),
    toHaveFoundOne: () => ({
        compare: (actual) => ({
            pass: actual.length === 1,
            message: `Expected to find exactly 1 but found ${actual.length}`,
        }),
    }),
    toHaveFoundMoreThan: () => ({
        compare: (actual, expected) => ({
            pass: actual.length > expected,
            message: `Expected to find more than ${expected} but found ${actual.length}`,
        }),
    }),
    toHaveFoundLessThan: () => ({
        compare: (actual, expected) => ({
            pass: actual.length < expected,
            message: `Expected to find less than ${expected} but found ${actual.length}`,
        }),
    }),
};
const jestMatchers = {
    toHaveFound: jasmineToJestMatcher(jasmineMatchers.toHaveFound),
    toHaveFoundLessThan: jasmineToJestMatcher(jasmineMatchers.toHaveFoundLessThan),
    toHaveFoundMoreThan: jasmineToJestMatcher(jasmineMatchers.toHaveFoundMoreThan),
    toHaveFoundOne: jasmineToJestMatcher(jasmineMatchers.toHaveFoundOne),
};
/////////////////////
// For Type-Safe enforcement only
const _jasmineTypeCheck = jasmineMatchers;
const _jestTypeCheck = jestMatchers;
_jasmineTypeCheck.toString();
_jestTypeCheck.toString();
if (typeof jest === 'undefined') {
    beforeEach(() => jasmine.addMatchers(jasmineMatchers));
}
else {
    beforeEach(() => expect.extend(jestMatchers));
}
//# sourceMappingURL=shallow-matchers.js.map