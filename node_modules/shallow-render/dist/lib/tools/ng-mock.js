"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ngMock = void 0;
const mock_module_1 = require("./mock-module");
const reflect_1 = require("./reflect");
const type_checkers_1 = require("./type-checkers");
const custom_error_1 = require("../models/custom-error");
const mock_pipe_1 = require("./mock-pipe");
const mock_directive_1 = require("./mock-directive");
const mock_component_1 = require("./mock-component");
const testing_1 = require("@angular/core/testing");
function ngMock(thing, setup) {
    const cached = setup.mockCache.find(thing);
    if (cached) {
        return cached;
    }
    if (Array.isArray(thing)) {
        return setup.mockCache.add(thing, thing.map(t => ngMock(t, setup))); // Recursion
    }
    if (setup.dontMock.includes(thing) || (type_checkers_1.isModuleWithProviders(thing) && setup.dontMock.includes(thing.ngModule))) {
        return thing;
    }
    let mock;
    try {
        if (reflect_1.ngModuleResolver.isNgModule(thing) || type_checkers_1.isModuleWithProviders(thing)) {
            mock = mock_module_1.mockModule(thing, setup);
        }
        else if (type_checkers_1.isPipeTransform(thing)) {
            mock = mock_pipe_1.mockPipe(thing, setup.mockPipes.get(thing));
        }
        else if (type_checkers_1.isClass(thing)) {
            const stubs = setup.mocks.get(thing);
            mock = type_checkers_1.declarationTypes(thing).includes('Component')
                ? mock_component_1.mockComponent(thing, { stubs })
                : mock_directive_1.mockDirective(thing, {
                    stubs,
                    renderContentsOnInit: setup.withStructuralDirectives.get(thing) ||
                        (setup.alwaysRenderStructuralDirectives && setup.withStructuralDirectives.get(thing) !== false),
                });
            fixEmptySelector(thing, mock);
        }
        else {
            throw new DoNotKnowHowToMockError(thing);
        }
    }
    catch (e) {
        throw new MockError(thing, e);
    }
    return setup.mockCache.add(thing, mock);
}
exports.ngMock = ngMock;
class DoNotKnowHowToMockError extends custom_error_1.CustomError {
    constructor(thing) {
        super(`Shallow doesn't know how to mock: ${thing}`);
    }
}
class MockError extends custom_error_1.CustomError {
    constructor(thing, error) {
        super(`Shallow ran into some trouble mocking ${(thing === null || thing === void 0 ? void 0 : thing.name) || thing}. Try skipping it with dontMock or neverMock.\n------------- MOCK ERROR -------------\n${(error === null || error === void 0 ? void 0 : error.stack) || error}\n----------- END MOCK ERROR -----------`);
    }
}
const fixEmptySelector = (thing, mock) => {
    const { selector } = reflect_1.directiveResolver.resolve(thing);
    if (!selector) {
        testing_1.TestBed.overrideDirective(mock, { add: { selector: `.__${mock.name}-selector` } });
    }
};
//# sourceMappingURL=ng-mock.js.map