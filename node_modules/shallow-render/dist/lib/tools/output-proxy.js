"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.outputProxy = exports.PropertyNotAnEventEmitterError = exports.PropertyNotMarkedAsOutputError = void 0;
const core_1 = require("@angular/core");
const custom_error_1 = require("../models/custom-error");
const reflect_1 = require("./reflect");
const className = (object) => (object && object.constructor && object.constructor.name) || '<UnknownClass>';
class PropertyNotMarkedAsOutputError extends custom_error_1.CustomError {
    constructor(key, component) {
        super(`${String(key)} is not marked with the @Output() decorator. ` +
            `Check that it is properly defined and set on the ${className(component)} class`);
    }
}
exports.PropertyNotMarkedAsOutputError = PropertyNotMarkedAsOutputError;
class PropertyNotAnEventEmitterError extends custom_error_1.CustomError {
    constructor(key, component) {
        super(`${String(key)} is not an instance of an EventEmitter. ` +
            `Check that it is properly defined and set on the ${className(component)} class`);
    }
}
exports.PropertyNotAnEventEmitterError = PropertyNotAnEventEmitterError;
const outputProxy = (component) => {
    const directive = component && 'constructor' in component && reflect_1.directiveResolver.resolve(component.constructor);
    const outputs = ((directive && directive.outputs) || []).map(output => output.split(':')[0]);
    return new Proxy({}, {
        get: (_, key) => {
            if (!outputs.includes(String(key))) {
                throw new PropertyNotMarkedAsOutputError(key, component);
            }
            const maybeOutput = component[key];
            if (!(maybeOutput instanceof core_1.EventEmitter)) {
                throw new PropertyNotAnEventEmitterError(key, component);
            }
            return maybeOutput;
        },
    });
};
exports.outputProxy = outputProxy;
//# sourceMappingURL=output-proxy.js.map