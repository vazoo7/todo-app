"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockProvider = void 0;
const core_1 = require("@angular/core");
const mock_of_provider_1 = require("../models/mock-of-provider");
const type_checkers_1 = require("./type-checkers");
const getProvide = (provider) => {
    if (Array.isArray(provider)) {
        return undefined;
    }
    else if (type_checkers_1.isTypeProvider(provider) || provider instanceof core_1.InjectionToken) {
        return provider;
    }
    else {
        return provider.provide;
    }
};
const recursiveFindProvider = (haystack, needle) => {
    for (const i of haystack) {
        if (Array.isArray(i)) {
            const found = recursiveFindProvider(i, needle); // Recursion
            if (found)
                return found;
        }
        else if (i === needle || (getProvide(i) && getProvide(i) === getProvide(needle))) {
            return i;
        }
    }
    return undefined;
};
function mockProvider(providerToMock, setup) {
    const provider = recursiveFindProvider(setup.providers, providerToMock) || providerToMock;
    if (Array.isArray(provider)) {
        return provider.map(p => mockProvider(p, setup)); // Recursion
    }
    else if (type_checkers_1.isExistingProvider(provider)) {
        return provider;
    }
    const provide = type_checkers_1.isTypeProvider(provider) ? provider : provider.provide;
    const isPipe = type_checkers_1.isPipeTransform(provide);
    const hasMocks = setup.mocks.has(provide) || setup.mockPipes.has(provide);
    const userMocks = isPipe
        ? Object.assign({ transform: setup.mockPipes.get(provide) || (() => '') }, setup.mocks.get(provide)) : setup.mocks.get(provide);
    // APP_INITIALIZERS break TestBed!
    // Do this until https://github.com/angular/angular/issues/24218 is fixed
    if (provide === core_1.APP_INITIALIZER) {
        return [];
    }
    // TODO: What if setup.dontMock.includes(provide.useClass)?
    if (!hasMocks && recursiveFindProvider(setup.dontMock, provider)) {
        return provider;
    }
    const prov = {
        provide,
        multi: 'multi' in provider && provider.multi,
    };
    if (provide instanceof core_1.InjectionToken && type_checkers_1.isValueProvider(provider)) {
        return Object.assign(Object.assign({}, prov), { useValue: hasMocks ? userMocks : `MOCKED_INJECTION_TOKEN_VALUE - ${provide.toString()}` });
    }
    const MockProvider = mock_of_provider_1.mockProviderClass(type_checkers_1.isClassProvider(provider) ? provider.useClass : provide, userMocks);
    if (type_checkers_1.isClassProvider(provider)) {
        return Object.assign(Object.assign({}, prov), { useClass: MockProvider });
    }
    if (type_checkers_1.isFactoryProvider(provider)) {
        return Object.assign(Object.assign({}, prov), { useFactory: () => new MockProvider() });
    }
    return Object.assign(Object.assign({}, prov), { useValue: new MockProvider() });
}
exports.mockProvider = mockProvider;
//# sourceMappingURL=mock-provider.js.map